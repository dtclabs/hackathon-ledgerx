/* tslint:disable */
/* eslint-disable */
/**
 * LedgerX Public API
 * ## Introduction  The LedgerX API provides endpoints for synchronizing on-chain wallets, retrieving normalized financial transactions, and managing wallets, wallet groups, organization members, and the accounting system (Chart of Accounts).  - **Security**: All endpoints (unless otherwise specified) require an **API_KEY**   in the request header. - **Rate Limit**: Depends on the user’s subscription plan. See details on the   subscriptions page. - **Compute Unit (CU)**: Each API consumes a specific number of CUs, which are   deducted from your monthly total.  **Useful Links**: - Rate limit: https://ledgerx.finance/subscriptions - Compute Unit: https://ledgerx.finance/subscriptions  > Note: Some CU and rate limit descriptions are for documentation purposes only. Actual limits are applied based on the user’s subscription plan. 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface ChartOfAccountMapping {
    'id'?: string;
    'type'?: string;
    'chartOfAccount'?: string | null;
    'walletId'?: string | null;
    'cryptocurrencyId'?: string | null;
    'recipientId'?: string | null;
    'direction'?: string | null;
}
export interface Contact {
    'organizationId'?: string;
    'name'?: string;
    'type'?: string;
    'typeId'?: string;
    'addresses'?: Array<ContactAddress>;
}
export interface ContactAddress {
    'address'?: string;
    'blockchainId'?: string | null;
}
export interface CreateChartOfAccount201Response {
    'data'?: ListChartOfAccounts200ResponseDataInner;
}
export interface CreateChartOfAccountRequest {
    'description'?: string;
    'code': string;
    'name': string;
    'type': CreateChartOfAccountRequestTypeEnum;
}

export const CreateChartOfAccountRequestTypeEnum = {
    Asset: 'ASSET',
    Liability: 'LIABILITY',
    Equity: 'EQUITY',
    Revenue: 'REVENUE',
    Expense: 'EXPENSE'
} as const;

export type CreateChartOfAccountRequestTypeEnum = typeof CreateChartOfAccountRequestTypeEnum[keyof typeof CreateChartOfAccountRequestTypeEnum];

export interface CreateWalletGroupRequest {
    'name': string;
    'supportedBlockchains': Array<string>;
}
export interface Cryptocurrency {
    'name'?: string;
    'publicId'?: string;
    'symbol'?: string;
    'image'?: CryptocurrencyImage;
    'isVerified'?: boolean;
    'addresses'?: Array<string>;
}
export interface CryptocurrencyImage {
    'large'?: string;
    'small'?: string;
    'thumb'?: string;
}
export interface FinancialTransaction {
    'id'?: string;
    'hash'?: string;
    'blockchainId'?: string;
    'fromAddress'?: string | null;
    'toAddress'?: string | null;
    'proxyAddress'?: string | null;
    'cryptocurrency'?: Cryptocurrency;
    'cryptocurrencyAmount'?: string;
    'valueTimestamp'?: string;
    'type'?: string;
    'typeDetail'?: FinancialTransactionTypeDetail;
    'status'?: string;
    'substatuses'?: Array<string>;
    'costBasis'?: number | null;
    /**
     * Fiat value (can be null if not available)
     */
    'fiatAmount'?: number | null;
    'fiatAmountPerUnit'?: number | null;
    'fiatCurrency'?: string | null;
    'gainLoss'?: number | null;
    'direction'?: string | null;
    'note'?: string | null;
    'invoiceId'?: string | null;
    'category'?: string | null;
    'correspondingChartOfAccount'?: string | null;
    'financialTransactionParent'?: FinancialTransactionParent;
    'fromContact'?: Contact;
    'toContact'?: Contact;
}
export interface FinancialTransactionParent {
    'hash'?: string;
    'blockchainId'?: string;
    'activity'?: string;
    'status'?: string;
    'exportStatus'?: string;
    'valueTimestamp'?: string;
    'childCount'?: number;
}
export interface FinancialTransactionTypeDetail {
    'value'?: string;
    'label'?: string;
}
export interface FinancialTransactionsResponse {
    'data'?: FinancialTransactionsResponseData;
}
export interface FinancialTransactionsResponseData {
    'items'?: Array<FinancialTransaction>;
    'pagination'?: Pagination;
}
export interface ImportWallets200Response {
    'jobIds'?: Array<string>;
}
export interface ImportWalletsRequest {
    'wallets': Array<string>;
}
/**
 * Response shape follows product payload
 */
export interface InviteMember201Response {
    'data'?: object;
}
export interface InviteMemberRequest {
    'address'?: string | null;
    'firstName': string;
    'lastName': string;
    'role': string;
    'email': string;
    'message'?: string | null;
}
export interface ListChartOfAccounts200Response {
    'data'?: Array<ListChartOfAccounts200ResponseDataInner>;
}
export interface ListChartOfAccounts200ResponseDataInner {
    'id'?: string;
    'name'?: string;
    'code'?: string;
    'type'?: string;
    'description'?: string;
    'status'?: string;
}
export interface ListCoaMappings200Response {
    'data'?: Array<ChartOfAccountMapping>;
}
export interface ListMembers200Response {
    'data'?: ListMembers200ResponseData;
}
export interface ListMembers200ResponseData {
    'totalItems'?: number;
    'totalPages'?: number;
    'currentPage'?: number;
    'items'?: Array<MembersListItem>;
    'limit'?: number;
}
export interface ListWalletGroups200Response {
    'data'?: Array<ListWalletGroups200ResponseDataInner>;
}
export interface ListWalletGroups200ResponseDataInner {
    'id'?: string;
    'name'?: string;
    'walletsSize'?: number;
    'supportedBlockchains'?: Array<string>;
}
export interface MembersListItem {
    'accountName'?: string;
    'authName'?: string;
    'firstName'?: string;
    'lastName'?: string;
    'accountImage'?: string | null;
    'role'?: string;
    'createdAt'?: string;
    'id'?: string;
    'organizationId'?: string;
}
export interface Pagination {
    'totalItems'?: number;
    'totalPages'?: number;
    'currentPage'?: number;
    'limit'?: number;
}
export interface SyncGetResponse {
    'status'?: SyncStatus;
    'walletId'?: string;
}


export interface SyncPostRequest {
    'walletId': string;
}
export interface SyncPostResponse {
    'jobId'?: string;
}
export interface SyncPutRequest {
    'action': SyncPutRequestActionEnum;
}

export const SyncPutRequestActionEnum = {
    Pause: 'PAUSE',
    Sync: 'SYNC'
} as const;

export type SyncPutRequestActionEnum = typeof SyncPutRequestActionEnum[keyof typeof SyncPutRequestActionEnum];


export const SyncStatus = {
    Done: 'DONE',
    Failed: 'FAILED',
    FetchingSignatures: 'FETCHING_SIGNATURES',
    FetchingTransactions: 'FETCHING_TRANSACTIONS'
} as const;

export type SyncStatus = typeof SyncStatus[keyof typeof SyncStatus];


export interface UpdateChartOfAccountRequest {
    'code': string;
    'name': string;
    'type': UpdateChartOfAccountRequestTypeEnum;
    'description'?: string;
}

export const UpdateChartOfAccountRequestTypeEnum = {
    Asset: 'ASSET',
    Liability: 'LIABILITY',
    Equity: 'EQUITY',
    Revenue: 'REVENUE',
    Expense: 'EXPENSE'
} as const;

export type UpdateChartOfAccountRequestTypeEnum = typeof UpdateChartOfAccountRequestTypeEnum[keyof typeof UpdateChartOfAccountRequestTypeEnum];

export interface UpdateWalletGroupRequest {
    'name': string;
}
export interface Wallet {
    'id'?: string;
    'name'?: string;
    'address'?: string;
    'sourceType'?: string;
    'flaggedAt'?: string | null;
    'group'?: WalletGroupRef;
    'balance'?: number | null;
    'status'?: string;
    'metadata'?: object | null;
    'lastSyncedAt'?: string | null;
    'createdAt'?: string;
    'supportedBlockchains'?: Array<string>;
    'ownedCryptocurrencies'?: object;
}
export interface WalletGroupRef {
    'id'?: string;
    'name'?: string;
}
export interface WalletListResponse {
    'data'?: WalletListResponseData;
}
export interface WalletListResponseData {
    'items'?: Array<Wallet>;
    'pagination'?: Pagination;
}

/**
 * ChartOfAccountsApi - axios parameter creator
 */
export const ChartOfAccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a Chart of Account
         * @param {CreateChartOfAccountRequest} createChartOfAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChartOfAccount: async (createChartOfAccountRequest: CreateChartOfAccountRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createChartOfAccountRequest' is not null or undefined
            assertParamExists('createChartOfAccount', 'createChartOfAccountRequest', createChartOfAccountRequest)
            const localVarPath = `/chart-of-accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API_KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createChartOfAccountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Chart of Accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listChartOfAccounts: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/chart-of-accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API_KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Chart of Accounts mappings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCoaMappings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/chart-of-accounts-mappings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API_KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Chart of Account
         * @param {string} coaId 
         * @param {UpdateChartOfAccountRequest} updateChartOfAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateChartOfAccount: async (coaId: string, updateChartOfAccountRequest: UpdateChartOfAccountRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'coaId' is not null or undefined
            assertParamExists('updateChartOfAccount', 'coaId', coaId)
            // verify required parameter 'updateChartOfAccountRequest' is not null or undefined
            assertParamExists('updateChartOfAccount', 'updateChartOfAccountRequest', updateChartOfAccountRequest)
            const localVarPath = `/chart-of-accounts/{coaId}`
                .replace(`{${"coaId"}}`, encodeURIComponent(String(coaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API_KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateChartOfAccountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChartOfAccountsApi - functional programming interface
 */
export const ChartOfAccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChartOfAccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a Chart of Account
         * @param {CreateChartOfAccountRequest} createChartOfAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createChartOfAccount(createChartOfAccountRequest: CreateChartOfAccountRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateChartOfAccount201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createChartOfAccount(createChartOfAccountRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChartOfAccountsApi.createChartOfAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Chart of Accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listChartOfAccounts(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListChartOfAccounts200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listChartOfAccounts(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChartOfAccountsApi.listChartOfAccounts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Chart of Accounts mappings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCoaMappings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListCoaMappings200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCoaMappings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChartOfAccountsApi.listCoaMappings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a Chart of Account
         * @param {string} coaId 
         * @param {UpdateChartOfAccountRequest} updateChartOfAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateChartOfAccount(coaId: string, updateChartOfAccountRequest: UpdateChartOfAccountRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateChartOfAccount(coaId, updateChartOfAccountRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChartOfAccountsApi.updateChartOfAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ChartOfAccountsApi - factory interface
 */
export const ChartOfAccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChartOfAccountsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a Chart of Account
         * @param {CreateChartOfAccountRequest} createChartOfAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChartOfAccount(createChartOfAccountRequest: CreateChartOfAccountRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateChartOfAccount201Response> {
            return localVarFp.createChartOfAccount(createChartOfAccountRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Chart of Accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listChartOfAccounts(options?: RawAxiosRequestConfig): AxiosPromise<ListChartOfAccounts200Response> {
            return localVarFp.listChartOfAccounts(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Chart of Accounts mappings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCoaMappings(options?: RawAxiosRequestConfig): AxiosPromise<ListCoaMappings200Response> {
            return localVarFp.listCoaMappings(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Chart of Account
         * @param {string} coaId 
         * @param {UpdateChartOfAccountRequest} updateChartOfAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateChartOfAccount(coaId: string, updateChartOfAccountRequest: UpdateChartOfAccountRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateChartOfAccount(coaId, updateChartOfAccountRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ChartOfAccountsApi - object-oriented interface
 */
export class ChartOfAccountsApi extends BaseAPI {
    /**
     * 
     * @summary Create a Chart of Account
     * @param {CreateChartOfAccountRequest} createChartOfAccountRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createChartOfAccount(createChartOfAccountRequest: CreateChartOfAccountRequest, options?: RawAxiosRequestConfig) {
        return ChartOfAccountsApiFp(this.configuration).createChartOfAccount(createChartOfAccountRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Chart of Accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listChartOfAccounts(options?: RawAxiosRequestConfig) {
        return ChartOfAccountsApiFp(this.configuration).listChartOfAccounts(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Chart of Accounts mappings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listCoaMappings(options?: RawAxiosRequestConfig) {
        return ChartOfAccountsApiFp(this.configuration).listCoaMappings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Chart of Account
     * @param {string} coaId 
     * @param {UpdateChartOfAccountRequest} updateChartOfAccountRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateChartOfAccount(coaId: string, updateChartOfAccountRequest: UpdateChartOfAccountRequest, options?: RawAxiosRequestConfig) {
        return ChartOfAccountsApiFp(this.configuration).updateChartOfAccount(coaId, updateChartOfAccountRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FinancialTransactionsApi - axios parameter creator
 */
export const FinancialTransactionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List financial transactions (paginated)
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFinancialTransactions: async (page?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/financial-transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API_KEY", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FinancialTransactionsApi - functional programming interface
 */
export const FinancialTransactionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FinancialTransactionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List financial transactions (paginated)
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFinancialTransactions(page?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FinancialTransactionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFinancialTransactions(page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FinancialTransactionsApi.listFinancialTransactions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FinancialTransactionsApi - factory interface
 */
export const FinancialTransactionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FinancialTransactionsApiFp(configuration)
    return {
        /**
         * 
         * @summary List financial transactions (paginated)
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFinancialTransactions(page?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<FinancialTransactionsResponse> {
            return localVarFp.listFinancialTransactions(page, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FinancialTransactionsApi - object-oriented interface
 */
export class FinancialTransactionsApi extends BaseAPI {
    /**
     * 
     * @summary List financial transactions (paginated)
     * @param {number} [page] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listFinancialTransactions(page?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return FinancialTransactionsApiFp(this.configuration).listFinancialTransactions(page, limit, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MembersApi - axios parameter creator
 */
export const MembersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deactivate a member
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateMember: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deactivateMember', 'id', id)
            const localVarPath = `/deactivate/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API_KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invite a new member
         * @param {InviteMemberRequest} inviteMemberRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteMember: async (inviteMemberRequest: InviteMemberRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'inviteMemberRequest' is not null or undefined
            assertParamExists('inviteMember', 'inviteMemberRequest', inviteMemberRequest)
            const localVarPath = `/invitations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API_KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inviteMemberRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List organization members (paginated)
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {ListMembersStateEnum} [state] Filter by state; leave empty to get all
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMembers: async (page?: number, size?: number, state?: ListMembersStateEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API_KEY", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MembersApi - functional programming interface
 */
export const MembersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MembersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Deactivate a member
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deactivateMember(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deactivateMember(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MembersApi.deactivateMember']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invite a new member
         * @param {InviteMemberRequest} inviteMemberRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inviteMember(inviteMemberRequest: InviteMemberRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InviteMember201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inviteMember(inviteMemberRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MembersApi.inviteMember']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List organization members (paginated)
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {ListMembersStateEnum} [state] Filter by state; leave empty to get all
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMembers(page?: number, size?: number, state?: ListMembersStateEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListMembers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMembers(page, size, state, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MembersApi.listMembers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MembersApi - factory interface
 */
export const MembersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MembersApiFp(configuration)
    return {
        /**
         * 
         * @summary Deactivate a member
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateMember(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deactivateMember(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invite a new member
         * @param {InviteMemberRequest} inviteMemberRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteMember(inviteMemberRequest: InviteMemberRequest, options?: RawAxiosRequestConfig): AxiosPromise<InviteMember201Response> {
            return localVarFp.inviteMember(inviteMemberRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List organization members (paginated)
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {ListMembersStateEnum} [state] Filter by state; leave empty to get all
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMembers(page?: number, size?: number, state?: ListMembersStateEnum, options?: RawAxiosRequestConfig): AxiosPromise<ListMembers200Response> {
            return localVarFp.listMembers(page, size, state, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MembersApi - object-oriented interface
 */
export class MembersApi extends BaseAPI {
    /**
     * 
     * @summary Deactivate a member
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deactivateMember(id: string, options?: RawAxiosRequestConfig) {
        return MembersApiFp(this.configuration).deactivateMember(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invite a new member
     * @param {InviteMemberRequest} inviteMemberRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public inviteMember(inviteMemberRequest: InviteMemberRequest, options?: RawAxiosRequestConfig) {
        return MembersApiFp(this.configuration).inviteMember(inviteMemberRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List organization members (paginated)
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {ListMembersStateEnum} [state] Filter by state; leave empty to get all
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listMembers(page?: number, size?: number, state?: ListMembersStateEnum, options?: RawAxiosRequestConfig) {
        return MembersApiFp(this.configuration).listMembers(page, size, state, options).then((request) => request(this.axios, this.basePath));
    }
}

export const ListMembersStateEnum = {
    Active: 'active',
    Deactivated: 'deactivated',
    Empty: ''
} as const;
export type ListMembersStateEnum = typeof ListMembersStateEnum[keyof typeof ListMembersStateEnum];


/**
 * SyncApi - axios parameter creator
 */
export const SyncApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Free for first 10,000 transactions, then costs **0.5 CU** per additional transaction.
         * @summary Request to sync a wallet
         * @param {SyncPostRequest} syncPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSyncJob: async (syncPostRequest: SyncPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'syncPostRequest' is not null or undefined
            assertParamExists('createSyncJob', 'syncPostRequest', syncPostRequest)
            const localVarPath = `/sync`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API_KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(syncPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check sync job status
         * @param {string} jobId Sync job identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSyncStatus: async (jobId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getSyncStatus', 'jobId', jobId)
            const localVarPath = `/sync`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API_KEY", configuration)

            if (jobId !== undefined) {
                localVarQueryParameter['jobId'] = jobId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Pause or continue a sync job
         * @param {string} jobId 
         * @param {SyncPutRequest} syncPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSyncJob: async (jobId: string, syncPutRequest: SyncPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('updateSyncJob', 'jobId', jobId)
            // verify required parameter 'syncPutRequest' is not null or undefined
            assertParamExists('updateSyncJob', 'syncPutRequest', syncPutRequest)
            const localVarPath = `/sync/{jobId}`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API_KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(syncPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SyncApi - functional programming interface
 */
export const SyncApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SyncApiAxiosParamCreator(configuration)
    return {
        /**
         * Free for first 10,000 transactions, then costs **0.5 CU** per additional transaction.
         * @summary Request to sync a wallet
         * @param {SyncPostRequest} syncPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSyncJob(syncPostRequest: SyncPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SyncPostResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSyncJob(syncPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SyncApi.createSyncJob']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Check sync job status
         * @param {string} jobId Sync job identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSyncStatus(jobId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SyncGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSyncStatus(jobId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SyncApi.getSyncStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Pause or continue a sync job
         * @param {string} jobId 
         * @param {SyncPutRequest} syncPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSyncJob(jobId: string, syncPutRequest: SyncPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSyncJob(jobId, syncPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SyncApi.updateSyncJob']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SyncApi - factory interface
 */
export const SyncApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SyncApiFp(configuration)
    return {
        /**
         * Free for first 10,000 transactions, then costs **0.5 CU** per additional transaction.
         * @summary Request to sync a wallet
         * @param {SyncPostRequest} syncPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSyncJob(syncPostRequest: SyncPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<SyncPostResponse> {
            return localVarFp.createSyncJob(syncPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check sync job status
         * @param {string} jobId Sync job identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSyncStatus(jobId: string, options?: RawAxiosRequestConfig): AxiosPromise<SyncGetResponse> {
            return localVarFp.getSyncStatus(jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Pause or continue a sync job
         * @param {string} jobId 
         * @param {SyncPutRequest} syncPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSyncJob(jobId: string, syncPutRequest: SyncPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateSyncJob(jobId, syncPutRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SyncApi - object-oriented interface
 */
export class SyncApi extends BaseAPI {
    /**
     * Free for first 10,000 transactions, then costs **0.5 CU** per additional transaction.
     * @summary Request to sync a wallet
     * @param {SyncPostRequest} syncPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createSyncJob(syncPostRequest: SyncPostRequest, options?: RawAxiosRequestConfig) {
        return SyncApiFp(this.configuration).createSyncJob(syncPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check sync job status
     * @param {string} jobId Sync job identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSyncStatus(jobId: string, options?: RawAxiosRequestConfig) {
        return SyncApiFp(this.configuration).getSyncStatus(jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Pause or continue a sync job
     * @param {string} jobId 
     * @param {SyncPutRequest} syncPutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateSyncJob(jobId: string, syncPutRequest: SyncPutRequest, options?: RawAxiosRequestConfig) {
        return SyncApiFp(this.configuration).updateSyncJob(jobId, syncPutRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WalletGroupsApi - axios parameter creator
 */
export const WalletGroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new wallet group
         * @param {CreateWalletGroupRequest} createWalletGroupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWalletGroup: async (createWalletGroupRequest: CreateWalletGroupRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createWalletGroupRequest' is not null or undefined
            assertParamExists('createWalletGroup', 'createWalletGroupRequest', createWalletGroupRequest)
            const localVarPath = `/wallet-groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API_KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createWalletGroupRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List wallet groups (paginated)
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWalletGroups: async (page?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/wallet-groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API_KEY", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a wallet group
         * @param {string} id 
         * @param {UpdateWalletGroupRequest} updateWalletGroupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWalletGroup: async (id: string, updateWalletGroupRequest: UpdateWalletGroupRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateWalletGroup', 'id', id)
            // verify required parameter 'updateWalletGroupRequest' is not null or undefined
            assertParamExists('updateWalletGroup', 'updateWalletGroupRequest', updateWalletGroupRequest)
            const localVarPath = `/wallet-groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API_KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateWalletGroupRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WalletGroupsApi - functional programming interface
 */
export const WalletGroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WalletGroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new wallet group
         * @param {CreateWalletGroupRequest} createWalletGroupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWalletGroup(createWalletGroupRequest: CreateWalletGroupRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListWalletGroups200ResponseDataInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWalletGroup(createWalletGroupRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletGroupsApi.createWalletGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List wallet groups (paginated)
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWalletGroups(page?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListWalletGroups200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWalletGroups(page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletGroupsApi.listWalletGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a wallet group
         * @param {string} id 
         * @param {UpdateWalletGroupRequest} updateWalletGroupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWalletGroup(id: string, updateWalletGroupRequest: UpdateWalletGroupRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWalletGroup(id, updateWalletGroupRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletGroupsApi.updateWalletGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WalletGroupsApi - factory interface
 */
export const WalletGroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WalletGroupsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new wallet group
         * @param {CreateWalletGroupRequest} createWalletGroupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWalletGroup(createWalletGroupRequest: CreateWalletGroupRequest, options?: RawAxiosRequestConfig): AxiosPromise<ListWalletGroups200ResponseDataInner> {
            return localVarFp.createWalletGroup(createWalletGroupRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List wallet groups (paginated)
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWalletGroups(page?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<ListWalletGroups200Response> {
            return localVarFp.listWalletGroups(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a wallet group
         * @param {string} id 
         * @param {UpdateWalletGroupRequest} updateWalletGroupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWalletGroup(id: string, updateWalletGroupRequest: UpdateWalletGroupRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateWalletGroup(id, updateWalletGroupRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WalletGroupsApi - object-oriented interface
 */
export class WalletGroupsApi extends BaseAPI {
    /**
     * 
     * @summary Create a new wallet group
     * @param {CreateWalletGroupRequest} createWalletGroupRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createWalletGroup(createWalletGroupRequest: CreateWalletGroupRequest, options?: RawAxiosRequestConfig) {
        return WalletGroupsApiFp(this.configuration).createWalletGroup(createWalletGroupRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List wallet groups (paginated)
     * @param {number} [page] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listWalletGroups(page?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return WalletGroupsApiFp(this.configuration).listWalletGroups(page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a wallet group
     * @param {string} id 
     * @param {UpdateWalletGroupRequest} updateWalletGroupRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateWalletGroup(id: string, updateWalletGroupRequest: UpdateWalletGroupRequest, options?: RawAxiosRequestConfig) {
        return WalletGroupsApiFp(this.configuration).updateWalletGroup(id, updateWalletGroupRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WalletsApi - axios parameter creator
 */
export const WalletsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Import and sync wallets
         * @param {ImportWalletsRequest} importWalletsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importWallets: async (importWalletsRequest: ImportWalletsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'importWalletsRequest' is not null or undefined
            assertParamExists('importWallets', 'importWalletsRequest', importWalletsRequest)
            const localVarPath = `/wallets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API_KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(importWalletsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of wallets
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWallets: async (page?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/wallets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API_KEY", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WalletsApi - functional programming interface
 */
export const WalletsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WalletsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Import and sync wallets
         * @param {ImportWalletsRequest} importWalletsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importWallets(importWalletsRequest: ImportWalletsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportWallets200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importWallets(importWalletsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletsApi.importWallets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get list of wallets
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWallets(page?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWallets(page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletsApi.listWallets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WalletsApi - factory interface
 */
export const WalletsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WalletsApiFp(configuration)
    return {
        /**
         * 
         * @summary Import and sync wallets
         * @param {ImportWalletsRequest} importWalletsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importWallets(importWalletsRequest: ImportWalletsRequest, options?: RawAxiosRequestConfig): AxiosPromise<ImportWallets200Response> {
            return localVarFp.importWallets(importWalletsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get list of wallets
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWallets(page?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<WalletListResponse> {
            return localVarFp.listWallets(page, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WalletsApi - object-oriented interface
 */
export class WalletsApi extends BaseAPI {
    /**
     * 
     * @summary Import and sync wallets
     * @param {ImportWalletsRequest} importWalletsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public importWallets(importWalletsRequest: ImportWalletsRequest, options?: RawAxiosRequestConfig) {
        return WalletsApiFp(this.configuration).importWallets(importWalletsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get list of wallets
     * @param {number} [page] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listWallets(page?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return WalletsApiFp(this.configuration).listWallets(page, limit, options).then((request) => request(this.axios, this.basePath));
    }
}



